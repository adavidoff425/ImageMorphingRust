# Graphical Image Morphing Tool 
## Alex Davidoff 
## ad35@pdx.edu
### Written in Rust using Feature-Based Image Morphing Algorithm
#### Uses Glium and Glutin Rust crates for image rendering 
#### NOTE: Only appears to work on Linux machines for the time being

###### For my final project I tried to implement a tool to morph two facial images together, something I had learned about but had never attempted in a computer vision course. I wanted to learn more about graphical and image crates available in Rust and felt this was a good way to do so, while also implementing something that is typically done in other languages. I was not able to find anyone who had attempted to implement this algorithm (Known as the Beier-Neely algorithm) in Rust. In order to do this, I created a imagemorph library crate that I was hoping could be used generally on different types and sizes of image, but I'm not sure I succeeded and ultimately wanted to just ensure that my program worked with the library functions.

###### To run the program, I've included two images, "will-smith.png" and "obama.png". Simply type "cargo run will-smith.png obama.png" or "cargo run obama.png will-smith.png" into the command line in order to build and run the program. 

###### In order to morph two images together, the program opens two separate windows, one image at a time. The user then draws lines using their mouse over the dominant features in the image, typically things like eyes, ears, mouth, facial structure, etc. Then the user should press 'X' on the window to exit. The next image then appears in a new window, and the user must draw the same number of lines for features in this image that would correspond to the first image. Then the user presses 'X' on this window and waits (it may take a minute or so) while the algorithm performs the process. Note it may appear like the display has frozen, and if a window says the process is not responding just wait while it finishes. Unfortunately I did not realize until I tested the app on another computer (both mac and windows), that the display I used only seems to work on Linux machines. 

###### Without going into too much detail, to morph two images together using feature lines, you first interpolate the feature lines from each of the two images so that you have one intermediate set for both images. Then each image is warped in order to meet this intermediate set of lines so that they may be overlaid onto each other. Using bilinear interpolation for each pixel, the final morphed image then takes a percentage (based on a parameter) of the color of each image's pixel at the same location. Once the process is complete, you will find a new image, "morphed.png" in the folder. Unfortunately I was not able to get it to morph quite as intended, but the result is still interesting and I still felt like the project was very beneficial to expanding my knowledge of Rust. The issues that the final product of this project have are due to my lack of mastery of the computer vision aspects, not due to any issues implementing the program itself.

###### Testing this project was a bit challenging since the value of things such as exact pixel locations and color values are very difficult to test for accurately, and testing that the graphical interface works properly was more of a visual matter than something that could be written into a test, but I did my best to come up with one or two tests for functions I had written in the morph library. 

###### Even though the morphing wasn't quite successful, I did feel that I succeeded in doing certain things in Rust that at first were quite challenging, such as drawing lines on an image and other features of glium and glutin that I struggled with for the first few weeks of working on this. I also did not previously have any experience with OpenGL, so on top of learning the pure rust bindings for that I was also learning how to use the software itself. 
